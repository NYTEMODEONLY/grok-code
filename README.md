# 🚀 Grok Code: AI-Powered CLI Coding Assistant with RPG Planning

<div align="center">

![Grok Code Logo](https://img.shields.io/badge/Grok_Code-CLI_AI_Assistant-000?style=for-the-badge&logo=terminal&logoColor=white)
![xAI Powered](https://img.shields.io/badge/Powered_by-xAI-000?style=for-the-badge&logo=x&logoColor=white)
![RPG Planning](https://img.shields.io/badge/Planning-RPG_Graph-FF6B35?style=for-the-badge&logo=graph&logoColor=white)

**Transform your terminal into an intelligent coding environment with AI planning and generation**

[Installation](#installation) • [Quick Start](#quick-start) • [RPG Planning](#rpg-repository-planning) • [Features](#key-features)

</div>

---

## ✨ Overview

**Grok Code** is a personal, terminal-based coding assistant powered by Grok AI models from xAI. It elevates your command line into an intelligent coding environment with **Repository Planning Graph (RPG)** technology - a structured approach to software architecture that ensures modular, well-planned code generation.

### 🎯 What Makes Grok Code Special?

- **🤖 AI-First Architecture**: Natural language prompts for any coding task
- **📊 RPG Planning**: Inspired by ["RPG: A Repository Planning Graph"](https://arxiv.org/abs/2509.16198) - structured planning before code generation
- **🧠 Memory System**: Remembers conversations across sessions with undo/redo
- **🔄 Stateful & Agentic**: Maintains context, plans ahead, and iterates autonomously
- **⚡ Full-Stack Ready**: From simple scripts to deploy-ready Next.js apps
- **🎨 Terminal-Native**: Designed for developers who live in the command line

### 🧠 **Revolutionary Intelligence Features**

**Phase 1: Enhanced Multi-File Intelligence**

- **🗂️ Semantic Code Parser**: AST-based analysis for JavaScript, TypeScript, and Python
- **🔗 Dependency Graph Engine**: Maps import/export relationships, detects circular dependencies, visualizes code architecture
- **🎯 Context Inference System**: Intelligent file relevance scoring, context window optimization, smart file suggestions
- **🔍 Intelligent File Linking**: Semantic search across codebases, auto-context building, token-efficient conversation management
- **💰 Context Budgeting**: Reserves capacity for different context types (essentials vs conversation) to prevent capacity exhaustion

**Phase 2: Advanced Error Recovery System**

- **🔍 Intelligent Error Detection**: Parses ESLint, TypeScript, Prettier output with context-aware analysis
- **🔧 Automated Fix Generation**: 20+ fix templates for common errors (semicolons, unused vars, imports, etc.)
- **🤖 AI-Powered Fixes**: Grok integration for complex error resolution with full codebase context
- **🛡️ Safe Fix Application**: Automatic backups, rollback capability, risk assessment, and validation
- **📊 Learning & Intelligence**: Cross-session error pattern analysis, personalized recommendations, and proactive prevention

**Phase 3: IDE-like Terminal Experience** _(Latest Addition)_

- **🎨 Syntax Highlighting**: Multi-language code highlighting (JavaScript, TypeScript, Python, JSON, Shell, SQL)
- **🌈 Multiple Color Themes**: Default, dark, and minimal themes with ANSI terminal compatibility
- **📊 Color-Coded Diff Display**: Unified diff parsing with green/red/gray color coding for additions/deletions
- **🔍 Git Integration**: `/diff git` command for seamless git diff workflows with syntax highlighting
- **⏳ Progress Indicators**: Advanced spinners and status displays for long-running operations
- **🗂️ Interactive File Browser**: Terminal navigation with arrow keys and file selection
- **📄 Enhanced Code Preview**: Line numbers, gutter, and IDE-style formatting with search highlighting
- **🔍 Interactive Code Search**: Multi-file, multi-mode search across entire codebases
- **⚡ Smart Command Interface**: Auto-complete for commands and file paths with intelligent suggestions
- **🕐 Advanced Command History**: Full-text search, time-based filtering, and usage analytics
- **🖼️ ASCII Art Workflow Diagrams**: Beautiful terminal visualizations of RPG plans and complex workflows

## 📋 Changelog

### v1.17.0 - Context-Aware Code Templates (Phase 4.4)
- **🔍 Intelligent Framework Detection**: Advanced analysis of project structure and dependencies
- **🎯 Comprehensive Framework Support**: React, Vue, Angular, Express, Django, Flask, FastAPI, and 30+ more
- **💻 Multi-Language Detection**: JavaScript, TypeScript, Python, Java, Go, Rust, PHP, Ruby support
- **📊 Confidence-Based Scoring**: High-accuracy detection with detailed confidence metrics
- **🏗️ Project Structure Analysis**: Deep analysis of file organization and patterns
- **🧩 Framework Pattern Recognition**: Identify hooks, components, lifecycle methods, and conventions
- **💡 Smart Recommendations**: Framework suggestions based on detected languages and patterns
- **🔬 Code Pattern Analysis**: Analyze specific files for framework-specific patterns and anti-patterns
- **⚙️ CLI Tool Detection**: Recognizes Commander.js, Inquirer.js, Ora, and other development tools
- **📋 Detailed Reporting**: Comprehensive analysis reports with export capabilities
- **🎭 Framework-Specific AI Prompts**: Context-aware prompts that adapt Grok's behavior to detected frameworks
- **📝 Intelligent Code Generation**: Framework-appropriate code generation with proper patterns and conventions
- **🔍 Smart Code Review**: Framework-aware code review focusing on relevant best practices
- **📏 Coding Standards Analysis**: Learns project-specific coding conventions and preferences
- **🔢 Code Style Intelligence**: Analyzes indentation, quotes, semicolons, naming patterns
- **📊 Project Statistics**: Line length, comment density, function length analysis
- **🧠 Team Learning System**: Learns from user interactions and corrections over time
- **🎯 Personalized Recommendations**: Builds confidence-based preferences from team behavior
- **📈 Adaptive Intelligence**: Evolves suggestions based on accepted vs rejected patterns
- **🔧 Auto-Apply Conventions**: Automatically format code to match learned standards
- **💾 Safe Application**: Automatic backups with rollback capability and dry-run mode
- **🎛️ Smart Fixes**: Quote normalization, indentation fixes, semicolon consistency
- **🏗️ Architecture Analysis**: Maps project to architectural patterns (MVC, Layered, Clean, Hexagonal, etc.)
- **📚 Layer Mapping**: Identifies Presentation, Business, Data, and Infrastructure layers
- **🔗 Component Relationships**: Analyzes dependencies between architectural components
- **🚪 Entry Point Detection**: Identifies application entry points and main flows
- **💡 Architectural Recommendations**: Suggests improvements and best practices
- **🌊 Flow Analysis**: Traces application execution paths and user journeys
- **🔄 Runtime Behavior**: Understands how applications actually work and flow
- **🛤️ User Journey Mapping**: Identifies primary user workflows and interactions
- **🔌 API Endpoint Discovery**: Maps RESTful endpoints and their purposes
- **💻 CLI Flow Analysis**: Understands command-line interfaces and their workflows
- **📁 Intelligent File Placement**: AI-powered suggestions for optimal file organization
- **🏛️ Architectural Layer Guidance**: Places files in appropriate presentation/business/data/infrastructure layers
- **🔧 Framework-Specific Placement**: Knows React components, Express routes, Angular services, etc.
- **📏 Convention-Aware Suggestions**: Respects project-specific coding standards and patterns
- **🔗 Relationship-Based Placement**: Suggests locations near related files and dependencies
- **🎯 Confidence Scoring**: Rates placement suggestions by appropriateness and likelihood
- **💡 Detailed Reasoning**: Explains why each placement suggestion is recommended
- **🎨 Context-Aware Code Templates**: AI-generated code that perfectly fits project architecture
- **🔧 Framework-Specific Code Generation**: React components, Express routes, Angular services, Django models
- **🏗️ Architecture-Conscious Templates**: MVC controllers, layered services, clean architecture use cases
- **📏 Convention-Following Generation**: Respects naming, imports, quotes, semicolons, indentation
- **📊 Project-Aware Intelligence**: Generates code based on detected frameworks and patterns
- **🔗 Integrated File Placement**: Suggests optimal locations for generated code
- **⚡ Instant Code Scaffolding**: Generate complete components, services, controllers, models, routes
- **🎯 Template Customization**: Adapts to team preferences and project-specific patterns
- **⚙️ Enhanced CLI Commands**: `/framework detect|patterns|analyze|prompts|conventions|learn|apply|architecture|flows|placement|template` for complete project intelligence

### v1.5.0 - IDE-like Terminal Experience (Phase 3.3)
- **⚡ Smart Command Interface**: Auto-complete system for commands and file paths with intelligent suggestions
- **🕐 Advanced Command History**: Full-text search across command history with time-based filtering and analytics
- **🔄 Intelligent Auto-Complete**: Fuzzy matching, priority-based sorting, and context-aware completions
- **📊 Command History Analytics**: Usage statistics, frequency analysis, and command pattern insights
- **🎯 Enhanced CLI Commands**: `/complete` for testing auto-complete, `/history` for advanced history management
- **🧠 IDE-like Experience**: Tab completion, command suggestions, and intelligent terminal interactions

### v1.4.0 - Complete Error Recovery System (Phase 2.4)

- **🔄 Automated Error Recovery Workflows**: End-to-end error recovery orchestration from detection to resolution
- **🐛 Interactive Debugging Sessions**: `/debug` command for guided error analysis and fix application
- **📈 Error Recovery Analytics**: Comprehensive statistics, success rates, and pattern analysis
- **🎯 Workflow Intelligence**: Context-aware recovery prioritization and batch processing
- **📊 Recovery Reporting**: Detailed insights, trends, and recommendations for error prevention
- **🛠️ Enhanced CLI Commands**: `/debug interactive|file|errors|fix|history|stats` for comprehensive error handling

### v1.3.0 - Interactive Code Display (Phase 3.2)

- **🗂️ Interactive File Browser**: Terminal navigation with arrow keys and file selection
- **📄 Enhanced Code Preview**: Line numbers, gutter, and IDE-style formatting
- **🎯 Line Navigation**: Jump to specific lines with contextual display
- **🔍 Search Highlighting**: Visual highlighting of search terms within code
- **💬 Code Annotations**: Inline comments and explanations for code sections
- **📊 File Intelligence**: Type icons, metadata, and syntax-highlighted previews
- **🎮 Interactive Commands**: `/browse`, `/preview` commands for advanced file operations

### v1.2.0 - IDE-like Terminal Experience (Phase 3.1)

- **🎨 Syntax Highlighting**: Multi-language code highlighting (JavaScript, TypeScript, Python, JSON, Shell, SQL)
- **🌈 Multiple Color Themes**: Default, dark, and minimal themes with ANSI terminal compatibility
- **📊 Color-Coded Diff Display**: Unified diff parsing with green/red/gray color coding for additions/deletions
- **🔍 Git Integration**: `/diff git` command for seamless git diff workflows with syntax highlighting
- **🎯 Interactive Controls**: `/highlight` and `/diff` commands for runtime theme switching and configuration
- **⏳ Progress Indicators**: Advanced spinners and status displays for operations

### v1.1.1 - CLI User Experience Improvements

- **✨ Enhanced CLI Experience**: Suppressed verbose internal logging from appearing in user console output
- **🔇 Clean Startup**: Removed detailed context loading and budget status messages during initialization
- **📝 Improved Logging**: INFO/WARN/DEBUG messages now only write to log files, keeping console clean for users
- **🐛 Bug Fixes**: Better error handling and user feedback for CLI operations

## 🏗️ RPG Repository Planning

**Repository Planning Graph (RPG)** is a cutting-edge approach to software architecture that structures code generation around modular planning. Inspired by the paper ["RPG: A Repository Planning Graph"](https://arxiv.org/abs/2509.16198), this feature ensures your generated codebases are well-organized, maintainable, and scalable.

### 📖 RPG Technical Details

RPG planning works by analyzing your request and creating a structured JSON plan with:

- **Features**: High-level functionalities to implement
- **Files**: Feature-to-file mapping for modular code generation
- **Flows**: Data flow relationships between features
- **Dependencies**: File dependency relationships

### Quick RPG Overview

1. **📋 Planning Phase**: Grok analyzes your request and creates a structured JSON plan
2. **🗂️ Graph Construction**: Builds a dependency graph with features and relationships
3. **⚙️ Guided Generation**: Uses the plan to generate modular, well-structured code
4. **💾 Direct Output**: Writes files directly to your filesystem

### When RPG Activates

RPG planning automatically triggers for prompts containing:

- `"generate repo"`, `"build a"`, `"create a"`
- `"implement a"`, `"develop a"`

**Example**: `"Build a simple ML library in JavaScript"` → RPG generates `src/data.js`, `src/model.js`, etc.

### 📁 [RPG Examples](./examples/)

Browse [example RPG plans](./examples/rpg-plans/) for different project types:

- [Machine Learning Library](./examples/rpg-plans/ml-library.json)
- [REST API](./examples/rpg-plans/rest-api.json)
- [CLI Tool](./examples/rpg-plans/cli-tool.json)

---

## ⚡ Key Features

Grok Code combines AI assistance with structured planning for unparalleled coding productivity:

### 🤖 AI-Powered Coding with RPG Planning

- **Intelligent Code Generation**: Natural language prompts powered by Grok AI
- **RPG Planning Integration**: Structured repository planning for complex projects
- **Step-by-Step Reasoning**: Grok thinks ahead, plans, and iterates on solutions
- **Multi-Paradigm Support**: Scripts, libraries, web apps, APIs, and more

### 🧠 Enhanced Multi-File Intelligence _(Phase 1)_

- **🗂️ Semantic Code Parser**:
  - AST-based analysis for JavaScript, TypeScript, and Python
  - Extracts functions, classes, imports, exports, and dependencies
  - Language-agnostic symbol extraction across multiple files

- **🔗 Dependency Graph Engine**:
  - Maps import/export relationships across entire codebases
  - Detects circular dependencies with detailed cycle analysis
  - ASCII visualization of code architecture and relationships
  - Interactive graph exploration and statistics

- **🎯 Context Inference System**:
  - Intelligent file relevance scoring based on semantic matching
  - Context window optimization for AI model token limits
  - Smart file suggestions based on coding task analysis
  - Task type detection (bugfix, feature, refactor, test, etc.)

- **🔍 Intelligent File Linking**:
  - Semantic search across codebases with meaning-based queries
  - Auto-context building from user queries and file relevance
  - Token-efficient conversation management with pruning strategies
  - Session-aware context that learns from interaction patterns

- **💰 Context Budgeting System** _(Latest Addition)_:
  - Reserves 15% for essential project files (package.json, README, etc.)
  - Allocates 70% for conversation and work context
  - Maintains 15% buffer for system overhead
  - Prevents capacity exhaustion while ensuring project awareness

### 🔧 Advanced Error Recovery System _(Phase 2)_

- **🔍 Intelligent Error Detection**:
  - Parses output from ESLint, TypeScript compiler, Prettier, and more
  - Classifies errors by type, severity, and fix complexity
  - Context-aware error analysis with codebase understanding
  - Impact assessment and prioritization

- **🔧 Automated Fix Generation**:
  - 20+ fix templates for common errors (missing semicolons, unused variables, imports)
  - Confidence-based auto-application (80%+ confidence = auto-fix)
  - Template → AI → Hybrid fallback strategy for maximum coverage
  - Intelligent method selection based on error characteristics

- **🤖 AI-Powered Fixes**:
  - Grok integration for complex error resolution
  - Full codebase context provided to AI for accurate fixes
  - Handles type mismatches, architectural issues, and complex logic errors
  - Structured fix output with explanations and warnings

- **🛡️ Safe Fix Application**:
  - Automatic file backups before any changes
  - Pre-flight checks (permissions, syntax validation, space)
  - Risk assessment with user confirmation for high-risk fixes
  - Instant rollback capability on any failure
  - Post-fix validation to ensure correctness

- **📊 Intelligent Learning Systems**:
  - **Error Pattern Analysis**: Cross-session tracking of error frequency, hotspots, and temporal patterns
  - **Personalized Recommendations**: User-specific fix preferences based on success history and project patterns
  - **Proactive Prevention**: Configuration suggestions, coding practice improvements, and architectural guidance
  - **Continuous Adaptation**: Learns from every interaction to provide better assistance over time

### 🗂️ Multi-File Management

- **Create, edit, or delete multiple files simultaneously using XML tags**
- **Automatic directory creation for complex project structures**

### 🎨 Syntax Highlighting

- **Multi-language support**: JavaScript, TypeScript, Python, JSON, Shell, SQL
- **Automatic language detection** from code content
- **Multiple color themes**: default, dark, minimal with ANSI terminal colors
- **Line numbers** and enhanced readability
- **Interactive controls**: `/highlight` command for runtime theme switching

### 📊 Color-Coded Diff Display

- **Unified diff parsing** with full color coding (green/red/gray)
- **Syntax highlighting within diffs** for enhanced readability
- **Git integration** with `/diff git` command for seamless workflow
- **Multi-file diff support** with language-aware highlighting
- **Diff summary statistics** and side-by-side comparisons
- **Interactive diff commands**: `/diff status/test/git/show`

### ⏳ Progress Indicators & Status Displays

- **Advanced spinner system** with multiple operation types and themes
- **Real-time progress feedback** for all long-running operations
- **Multi-step progress tracking** with sequential execution visualization
- **Status indicators** with success/error/warning/info/pending states
- **Performance timing** with formatted duration displays
- **Interactive progress commands**: `/progress status/test/spinner/multistep`

### 🗂️ Interactive File Browser

- **Terminal navigation** with arrow keys and intuitive file selection
- **File type icons** with emoji indicators (📁 directories, 🟨 JS, 🔷 TS, 🐍 Python, etc.)
- **Syntax-highlighted previews** with metadata (size, type, modification date)
- **Context integration** to add selected files to AI conversation
- **Search and filtering** across directory trees
- **Interactive browser commands**: `/browse start/find/preview/stats`

### 📄 Enhanced Code Preview

- **Line numbers and gutter** with IDE-style formatting and navigation
- **Syntax highlighting** integrated with multi-language support
- **Line highlighting and navigation** with context-aware display
- **Search and highlight** functionality within code files
- **Code annotations** with inline comments and explanations
- **File metadata display** with size, type, and modification info
- **Interactive preview commands**: `/preview file/line/search/code/config`

### 🔍 Interactive Code Search

- **Multi-file codebase search** with configurable search modes
- **Regex pattern matching** with fuzzy and whole word search options
- **File type filtering** (JavaScript, TypeScript, Python, web files, configs)
- **Real-time result highlighting** with context previews and line numbers
- **Search history tracking** and usage statistics
- **Interactive search interface** with guided menu-driven experience
- **Advanced search commands**: `/search query/regex/word/fuzzy/interactive/history/stats`

### 🔄 Autonomous Workflows

- **Execute shell commands via `<run command="...">` tags (npm install, tests, linting)**
- **Iterative error handling with AI-suggested fixes**
- **End-to-end project generation with deployment commands**
- **Error recovery workflows** with automatic fix suggestions

### 🌐 Git Integration

- **Built-in commands**: `/git <command>`, `/init-git`, `/commit <message>`, `/push`
- **Automated git workflows and PR creation (requires `gh` CLI)**
- **Conflict resolution and commit message generation**

### ⚙️ Custom Commands & Configuration

- **Define reusable prompts in `.grok/commands/<cmd_name>.txt`**
- **Team-shared commands for project consistency**
- **GROK.md**: Project-specific guidelines and commands\*\*
- **Context budgeting configuration** for custom capacity allocation

### 🧠 Memory & History System

- **Conversation persistence across CLI sessions**
- **Action history with undo/redo functionality (`/undo`)**
- **Context window management** with intelligent budgeting
- **Automatic conversation compression and summarization**

### 🖥️ Environment Awareness

- **Cross-platform support (Windows, macOS, Linux)**
- **OS-adapted commands and paths**
- **Stateful conversation with full context retention**
- **Model selection with platform-optimized defaults**

### 🎨 Terminal-First UX

- **Thinking animations during API calls**
- **Interactive confirmation for high-risk actions**
- **Comprehensive help system with `/help`**
- **Context capacity dashboard with `/budget`**
- **Session management with `/clear`**

### 🔧 Configuration & Extensibility

- **`GROK.md`**: Project-specific guidelines and commands\*\*
- **Secure API key management with local storage**
- **Model Selection**: Choose from multiple Grok models via `/model` command:
  - `grok-code-fast-1`: **Default** - Optimized for coding, fast & cost-effective
  - `grok-4-fast-reasoning`: Best for complex reasoning (RPG planning), 2M context
  - `grok-4-fast-non-reasoning`: Fast for simple tasks, 2M context, low cost
  - `grok-3-beta`: Legacy - Most capable, balanced performance
  - `grok-3-mini-beta`: Legacy - Faster, lower cost
  - `grok-beta`: Legacy - Original model
- **Environment variables**: Set `GROK_MODEL` to override default

### 🛡️ Security & Best Practices

- **User confirmation required for high-risk fixes**
- **Automatic backups and rollback for all changes**
- **Token-efficient context management with budgeting**
- **Pre-flight validation for all fix applications**
- **No automatic execution without approval**

## Installation

1. **Prerequisites**:
   - Node.js 16+.
   - xAI API key (get from [x.ai/api](https://x.ai/api)).

2. **Clone the Repo**:

   ```bash
   git clone https://github.com/NYTEMODEONLY/grok-code.git
   cd grok-code
   ```

3. **Install Dependencies**:

   ```bash
   npm install
   ```

4. **Run the CLI**:

   ```bash
   npm start
   ```

   or

   ```bash
   ./bin/grok.js
   ```

   - On first launch, enter your xAI API key (saved securely in `~/.grok/api_key`).

5. **Global Installation (Optional)**:
   ```bash
   npm install -g .
   ```
   Or install from npm (once published):
   ```bash
   npm install -g grok-code-cli
   ```
   Then use `grok` from anywhere.

## 🚀 Quick Start

Get started with Grok Code in seconds:

```bash
# Clone and install
git clone https://github.com/NYTEMODEONLY/grok-code.git
cd grok-code
npm install

# Launch
npm start
```

Or install globally for system-wide access:

```bash
npm install -g grok-code-cli
grok
```

### 💡 Usage Examples

#### 🏗️ RPG Planning (Recommended for Complex Projects)

```bash
# Automatic RPG activation
"Build a simple ML library in JavaScript"
"Create a REST API for task management"
"Implement a React dashboard with charts"
"Develop a Node.js CLI tool for file processing"
```

#### 🤖 Regular AI Chat

```bash
# General coding assistance
"Write a function to validate email addresses"
"Debug this JavaScript error: [paste error]"
"Optimize this SQL query for performance"
```

#### 🔧 Workflow Commands

```bash
# Model selection
"/model"                       # Change AI model (interactive menu)

# Context management
"/budget"                      # Show context capacity and usage breakdown
"/add src/app.js"              # Add file to conversation context (capacity-aware)
/scan                          # Scan all files (with capacity warnings)
/remove src/app.js             # Remove file from context and free capacity

# Git operations
"/init-git"                    # Initialize repository
"/commit Add new feature"      # Stage and commit
"/push"                        # Push to remote

# File management
"/ls"                          # List directory

# Memory & history
"/undo"                        # Undo the last file operation
"/clear"                       # Clear conversation history

# Custom commands
"/test"                        # Run tests (if defined)

# Error recovery (Phase 2)
# Just paste error output - Grok Code will analyze and suggest fixes
# Example: Paste ESLint/TypeScript errors for automatic analysis
```

Exit anytime with `exit` or `/exit`. Conversations are automatically saved and restored between sessions.

### 📋 Example Sessions

#### 🏗️ RPG Planning Example

```bash
Welcome to Grok Code! Type your message or use /help for commands.

You: Build a simple ML library in JavaScript

Grok: Using RPG planning for code generation...
RPG Plan Generated: {
  "features": ["data_loading", "model_training", "prediction"],
  "files": {"data_loading": "src/data.js", "model_training": "src/model.js"},
  "flows": [["data_loading", "model_training"]],
  "deps": [["data.js", "model.js"]]
}

Generated: src/data.js
Generated: src/model.js
Generated: package.json

Repository generation completed!
```

#### 🤖 Interactive Development Example

**Create and test code instantly:**

```bash
# User creates a function
You: Create a function to reverse a string in JavaScript

Grok: Here's a simple function to reverse a string:
```

```javascript
function reverseString(str) {
  return str.split('').reverse().join('');
}
```

```bash
# User immediately tests the function
You: /run node -e "console.log(reverseString('hello'))"

[Command executed: node -e "console.log(reverseString('hello'))"]
Output: olleh
```

#### 🛡️ Error Recovery System Example

```bash
# User encounters a linting error
You: [pastes ESLint output]
src/auth.js:15:25: Missing semicolon (semi)
src/auth.js:20:7: 'unusedVar' is defined but never used (no-unused-vars)

Grok: 🔍 Analyzing 2 errors across your codebase...

Error Analysis:
• SYNTAX: Missing semicolon (High confidence auto-fix available)
• UNUSED: Unused variable (High confidence auto-fix available)

🤖 Applying fixes...
✅ Fixed: Missing semicolon in src/auth.js:15
✅ Fixed: Removed unused variable 'unusedVar' in src/auth.js:20

All errors resolved! Your code is now clean.
```

#### 💰 Context Budgeting Example

```bash
# Check context capacity
You: /budget

💰 Context Budget Status:
════════════════════════════════════════════════════════
Total Usage: 15% (1200/8000 tokens)
Available: 6800 tokens

Budget Categories:
  essentials ████████░░░░ 15% (1200/8000)
  conversation ░░░░░░░░░░ 0% (0/5600)
  buffer ████████░░░░ 15% (1200/8000)

💡 Tips:
   • You have 5600 tokens available for conversation
   • Essentials usage is optimal (README.md, package.json loaded)

# Add a file to conversation context
You: /add src/utils/helpers.js
✅ Added src/utils/helpers.js to context (450 tokens).
💰 Conversation capacity: 5150 tokens remaining

# View updated budget
You: /budget
[Shows updated usage with conversation category now active]
```

## 💡 Best Practices & Tips

### 🏗️ RPG Planning Tips

- **Use Descriptive Prompts**: "Build a REST API for user authentication" works better than "Make an API"
- **Complex Projects**: Always use RPG for multi-feature projects to ensure proper architecture
- **Review Plans**: RPG plans are logged to console—review them before generation
- **Fallback Available**: If RPG fails, Grok Code automatically falls back to regular chat

### 🤖 General AI Usage

- **Context Matters**: Add relevant files with `/add <file>` before complex tasks
- **Iterative Development**: Use Grok's error analysis for debugging workflows
- **Token Efficiency**: Add files selectively rather than scanning everything

### 📁 Project Configuration

- **GROK.md**: Define project standards:

  ```markdown
  # Project Standards

  - Style: ESLint with Airbnb preset
  - Build: npm run build
  - Test: npm test
  - Architecture: Feature-based folder structure
  ```

- **Custom Commands**: Create reusable workflows:
  ```bash
  # .grok/commands/deploy.txt
  Deploy the current Next.js app to Vercel and output the URL.
  ```

### 💰 Context Budgeting Best Practices

- **Monitor Capacity**: Use `/budget` regularly to understand your context usage
- **Essential Files**: Only README.md and package.json are auto-loaded - add others manually
- **Conversation Priority**: Reserve most capacity (70%) for actual work discussions
- **Capacity Warnings**: Pay attention to capacity warnings when adding files
- **Selective Addition**: Use `/add <file>` instead of `/scan` for better capacity control

### 🔧 Error Recovery Tips

- **Paste Raw Errors**: Just paste ESLint/TypeScript errors directly - Grok Code analyzes automatically
- **Trust Auto-Fixes**: High-confidence fixes (>80%) are applied automatically and safely
- **Review AI Fixes**: Lower-confidence fixes show suggestions instead of auto-applying
- **Rollback Ready**: All fixes can be rolled back instantly if something goes wrong
- **Context Matters**: Add relevant files before fixing complex errors for better results

### ⚡ Performance Optimization

- **Model Selection**: Use `/model` command to choose the right model for your task:
  - **Coding tasks**: `grok-code-fast-1` (default - optimized for code)
  - **Complex reasoning/RPG**: `grok-4-fast-reasoning` (2M context, excellent reasoning)
  - **Simple/fast tasks**: `grok-4-fast-non-reasoning` (2M context, low cost)
  - **High quality**: `grok-3-beta` (legacy - most capable)
  - **Speed/cost**: `grok-3-mini-beta` (legacy - fastest)
- **Context Management**: Use `/budget` to monitor capacity instead of clearing sessions
- **Selective Scanning**: Use `/add` with capacity awareness for large codebases
- **Fix Learning**: The system learns from your fix patterns for better suggestions

## 🤝 Contributing

We love contributions! Whether it's bug fixes, new features, or documentation improvements, every contribution helps make Grok Code better.

### 🚀 How to Contribute

1. **Fork** the repository on GitHub
2. **Clone** your fork: `git clone https://github.com/your-username/grok-code.git`
3. **Create** a feature branch: `git checkout -b feature/amazing-feature`
4. **Make** your changes and test thoroughly
5. **Commit** with clear messages: `git commit -m "Add amazing feature"`
6. **Push** to your branch: `git push origin feature/amazing-feature`
7. **Open** a Pull Request with a detailed description

### 🐛 Found a Bug?

- Check [existing issues](https://github.com/NYTEMODEONLY/grok-code/issues) first
- Open a new issue with detailed steps to reproduce
- Include your OS, Node.js version, and error messages

### 💡 Feature Requests

- Use GitHub Discussions for feature ideas
- Check if the feature aligns with RPG planning principles
- Provide use cases and examples

## 📄 License

This project is licensed under the MIT License - see the [LICENSE](LICENSE) file for details.

## 🙏 Acknowledgments

- **🤖 Powered by** [xAI's Grok](https://x.ai) models - The foundation of intelligent assistance
- **📚 Inspired by** ["RPG: A Repository Planning Graph"](https://arxiv.org/abs/2509.16198) - Structured planning for better code generation
- **👨‍💻 Built by** nytemode - Personal project exploring AI-assisted development
- **🌟 xAI Community** - For providing the amazing models that make this possible

_This is a personal project and not officially affiliated with xAI._

## 📞 Support & Community

- **🐛 Issues**: [GitHub Issues](https://github.com/NYTEMODEONLY/grok-code/issues)
- **💬 Discussions**: [GitHub Discussions](https://github.com/NYTEMODEONLY/grok-code/discussions)
- **🐦 Twitter**: Follow [@xai](https://twitter.com/xai) for updates
- **📧 Contact**: Open an issue for direct support

---

<div align="center">

**Ready to revolutionize your coding workflow?** 🚀

[Get Started](#quick-start) • [RPG Planning](#rpg-repository-planning) • [Contribute](#contributing)

_Made with ❤️ by nytemode_

</div>
