# ğŸš€ Grok Code: AI-Powered CLI Coding Assistant with RPG Planning

<div align="center">

![Grok Code Logo](https://img.shields.io/badge/Grok_Code-CLI_AI_Assistant-000?style=for-the-badge&logo=terminal&logoColor=white)
![xAI Powered](https://img.shields.io/badge/Powered_by-xAI-000?style=for-the-badge&logo=x&logoColor=white)
![RPG Planning](https://img.shields.io/badge/Planning-RPG_Graph-FF6B35?style=for-the-badge&logo=graph&logoColor=white)

**Transform your terminal into an intelligent coding environment with AI planning and generation**

[Installation](#installation) â€¢ [Quick Start](#quick-start) â€¢ [RPG Planning](#rpg-repository-planning) â€¢ [Features](#key-features)

</div>

---

## âœ¨ Overview

**Grok Code** is a personal, terminal-based coding assistant powered by Grok AI models from xAI. It elevates your command line into an intelligent coding environment with **Repository Planning Graph (RPG)** technology - a structured approach to software architecture that ensures modular, well-planned code generation.

### ğŸ¯ What Makes Grok Code Special?

- **ğŸ¤– AI-First Architecture**: Natural language prompts for any coding task
- **ğŸ“Š RPG Planning**: Inspired by ["RPG: A Repository Planning Graph"](https://arxiv.org/abs/2509.16198) - structured planning before code generation
- **ğŸ§  Memory System**: Remembers conversations across sessions with undo/redo
- **ğŸ”„ Stateful & Agentic**: Maintains context, plans ahead, and iterates autonomously
- **âš¡ Full-Stack Ready**: From simple scripts to deploy-ready Next.js apps
- **ğŸ¨ Terminal-Native**: Designed for developers who live in the command line

### ğŸ§  **Revolutionary Intelligence Features**

**Phase 1: Enhanced Multi-File Intelligence**

- **ğŸ—‚ï¸ Semantic Code Parser**: AST-based analysis for JavaScript, TypeScript, and Python
- **ğŸ”— Dependency Graph Engine**: Maps import/export relationships, detects circular dependencies, visualizes code architecture
- **ğŸ¯ Context Inference System**: Intelligent file relevance scoring, context window optimization, smart file suggestions
- **ğŸ” Intelligent File Linking**: Semantic search across codebases, auto-context building, token-efficient conversation management
- **ğŸ’° Context Budgeting**: Reserves capacity for different context types (essentials vs conversation) to prevent capacity exhaustion

**Phase 2: Advanced Error Recovery System**

- **ğŸ” Intelligent Error Detection**: Parses ESLint, TypeScript, Prettier output with context-aware analysis
- **ğŸ”§ Automated Fix Generation**: 20+ fix templates for common errors (semicolons, unused vars, imports, etc.)
- **ğŸ¤– AI-Powered Fixes**: Grok integration for complex error resolution with full codebase context
- **ğŸ›¡ï¸ Safe Fix Application**: Automatic backups, rollback capability, risk assessment, and validation
- **ğŸ“Š Learning & Intelligence**: Cross-session error pattern analysis, personalized recommendations, and proactive prevention

**Phase 3: IDE-like Terminal Experience** _(Latest Addition)_

- **ğŸ¨ Syntax Highlighting**: Multi-language code highlighting (JavaScript, TypeScript, Python, JSON, Shell, SQL)
- **ğŸŒˆ Multiple Color Themes**: Default, dark, and minimal themes with ANSI terminal compatibility
- **ğŸ“Š Color-Coded Diff Display**: Unified diff parsing with green/red/gray color coding for additions/deletions
- **ğŸ” Git Integration**: `/diff git` command for seamless git diff workflows with syntax highlighting
- **â³ Progress Indicators**: Advanced spinners and status displays for long-running operations
- **ğŸ—‚ï¸ Interactive File Browser**: Terminal navigation with arrow keys and file selection
- **ğŸ“„ Enhanced Code Preview**: Line numbers, gutter, and IDE-style formatting with search highlighting
- **ğŸ” Interactive Code Search**: Multi-file, multi-mode search across entire codebases
- **âš¡ Smart Command Interface**: Auto-complete for commands and file paths with intelligent suggestions
- **ğŸ• Advanced Command History**: Full-text search, time-based filtering, and usage analytics
- **ğŸ–¼ï¸ ASCII Art Workflow Diagrams**: Beautiful terminal visualizations of RPG plans and complex workflows

## ğŸ“‹ Changelog

### v1.17.0 - Context-Aware Code Templates (Phase 4.4)
- **ğŸ” Intelligent Framework Detection**: Advanced analysis of project structure and dependencies
- **ğŸ¯ Comprehensive Framework Support**: React, Vue, Angular, Express, Django, Flask, FastAPI, and 30+ more
- **ğŸ’» Multi-Language Detection**: JavaScript, TypeScript, Python, Java, Go, Rust, PHP, Ruby support
- **ğŸ“Š Confidence-Based Scoring**: High-accuracy detection with detailed confidence metrics
- **ğŸ—ï¸ Project Structure Analysis**: Deep analysis of file organization and patterns
- **ğŸ§© Framework Pattern Recognition**: Identify hooks, components, lifecycle methods, and conventions
- **ğŸ’¡ Smart Recommendations**: Framework suggestions based on detected languages and patterns
- **ğŸ”¬ Code Pattern Analysis**: Analyze specific files for framework-specific patterns and anti-patterns
- **âš™ï¸ CLI Tool Detection**: Recognizes Commander.js, Inquirer.js, Ora, and other development tools
- **ğŸ“‹ Detailed Reporting**: Comprehensive analysis reports with export capabilities
- **ğŸ­ Framework-Specific AI Prompts**: Context-aware prompts that adapt Grok's behavior to detected frameworks
- **ğŸ“ Intelligent Code Generation**: Framework-appropriate code generation with proper patterns and conventions
- **ğŸ” Smart Code Review**: Framework-aware code review focusing on relevant best practices
- **ğŸ“ Coding Standards Analysis**: Learns project-specific coding conventions and preferences
- **ğŸ”¢ Code Style Intelligence**: Analyzes indentation, quotes, semicolons, naming patterns
- **ğŸ“Š Project Statistics**: Line length, comment density, function length analysis
- **ğŸ§  Team Learning System**: Learns from user interactions and corrections over time
- **ğŸ¯ Personalized Recommendations**: Builds confidence-based preferences from team behavior
- **ğŸ“ˆ Adaptive Intelligence**: Evolves suggestions based on accepted vs rejected patterns
- **ğŸ”§ Auto-Apply Conventions**: Automatically format code to match learned standards
- **ğŸ’¾ Safe Application**: Automatic backups with rollback capability and dry-run mode
- **ğŸ›ï¸ Smart Fixes**: Quote normalization, indentation fixes, semicolon consistency
- **ğŸ—ï¸ Architecture Analysis**: Maps project to architectural patterns (MVC, Layered, Clean, Hexagonal, etc.)
- **ğŸ“š Layer Mapping**: Identifies Presentation, Business, Data, and Infrastructure layers
- **ğŸ”— Component Relationships**: Analyzes dependencies between architectural components
- **ğŸšª Entry Point Detection**: Identifies application entry points and main flows
- **ğŸ’¡ Architectural Recommendations**: Suggests improvements and best practices
- **ğŸŒŠ Flow Analysis**: Traces application execution paths and user journeys
- **ğŸ”„ Runtime Behavior**: Understands how applications actually work and flow
- **ğŸ›¤ï¸ User Journey Mapping**: Identifies primary user workflows and interactions
- **ğŸ”Œ API Endpoint Discovery**: Maps RESTful endpoints and their purposes
- **ğŸ’» CLI Flow Analysis**: Understands command-line interfaces and their workflows
- **ğŸ“ Intelligent File Placement**: AI-powered suggestions for optimal file organization
- **ğŸ›ï¸ Architectural Layer Guidance**: Places files in appropriate presentation/business/data/infrastructure layers
- **ğŸ”§ Framework-Specific Placement**: Knows React components, Express routes, Angular services, etc.
- **ğŸ“ Convention-Aware Suggestions**: Respects project-specific coding standards and patterns
- **ğŸ”— Relationship-Based Placement**: Suggests locations near related files and dependencies
- **ğŸ¯ Confidence Scoring**: Rates placement suggestions by appropriateness and likelihood
- **ğŸ’¡ Detailed Reasoning**: Explains why each placement suggestion is recommended
- **ğŸ¨ Context-Aware Code Templates**: AI-generated code that perfectly fits project architecture
- **ğŸ”§ Framework-Specific Code Generation**: React components, Express routes, Angular services, Django models
- **ğŸ—ï¸ Architecture-Conscious Templates**: MVC controllers, layered services, clean architecture use cases
- **ğŸ“ Convention-Following Generation**: Respects naming, imports, quotes, semicolons, indentation
- **ğŸ“Š Project-Aware Intelligence**: Generates code based on detected frameworks and patterns
- **ğŸ”— Integrated File Placement**: Suggests optimal locations for generated code
- **âš¡ Instant Code Scaffolding**: Generate complete components, services, controllers, models, routes
- **ğŸ¯ Template Customization**: Adapts to team preferences and project-specific patterns
- **âš™ï¸ Enhanced CLI Commands**: `/framework detect|patterns|analyze|prompts|conventions|learn|apply|architecture|flows|placement|template` for complete project intelligence

### v1.5.0 - IDE-like Terminal Experience (Phase 3.3)
- **âš¡ Smart Command Interface**: Auto-complete system for commands and file paths with intelligent suggestions
- **ğŸ• Advanced Command History**: Full-text search across command history with time-based filtering and analytics
- **ğŸ”„ Intelligent Auto-Complete**: Fuzzy matching, priority-based sorting, and context-aware completions
- **ğŸ“Š Command History Analytics**: Usage statistics, frequency analysis, and command pattern insights
- **ğŸ¯ Enhanced CLI Commands**: `/complete` for testing auto-complete, `/history` for advanced history management
- **ğŸ§  IDE-like Experience**: Tab completion, command suggestions, and intelligent terminal interactions

### v1.4.0 - Complete Error Recovery System (Phase 2.4)

- **ğŸ”„ Automated Error Recovery Workflows**: End-to-end error recovery orchestration from detection to resolution
- **ğŸ› Interactive Debugging Sessions**: `/debug` command for guided error analysis and fix application
- **ğŸ“ˆ Error Recovery Analytics**: Comprehensive statistics, success rates, and pattern analysis
- **ğŸ¯ Workflow Intelligence**: Context-aware recovery prioritization and batch processing
- **ğŸ“Š Recovery Reporting**: Detailed insights, trends, and recommendations for error prevention
- **ğŸ› ï¸ Enhanced CLI Commands**: `/debug interactive|file|errors|fix|history|stats` for comprehensive error handling

### v1.3.0 - Interactive Code Display (Phase 3.2)

- **ğŸ—‚ï¸ Interactive File Browser**: Terminal navigation with arrow keys and file selection
- **ğŸ“„ Enhanced Code Preview**: Line numbers, gutter, and IDE-style formatting
- **ğŸ¯ Line Navigation**: Jump to specific lines with contextual display
- **ğŸ” Search Highlighting**: Visual highlighting of search terms within code
- **ğŸ’¬ Code Annotations**: Inline comments and explanations for code sections
- **ğŸ“Š File Intelligence**: Type icons, metadata, and syntax-highlighted previews
- **ğŸ® Interactive Commands**: `/browse`, `/preview` commands for advanced file operations

### v1.2.0 - IDE-like Terminal Experience (Phase 3.1)

- **ğŸ¨ Syntax Highlighting**: Multi-language code highlighting (JavaScript, TypeScript, Python, JSON, Shell, SQL)
- **ğŸŒˆ Multiple Color Themes**: Default, dark, and minimal themes with ANSI terminal compatibility
- **ğŸ“Š Color-Coded Diff Display**: Unified diff parsing with green/red/gray color coding for additions/deletions
- **ğŸ” Git Integration**: `/diff git` command for seamless git diff workflows with syntax highlighting
- **ğŸ¯ Interactive Controls**: `/highlight` and `/diff` commands for runtime theme switching and configuration
- **â³ Progress Indicators**: Advanced spinners and status displays for operations

### v1.1.1 - CLI User Experience Improvements

- **âœ¨ Enhanced CLI Experience**: Suppressed verbose internal logging from appearing in user console output
- **ğŸ”‡ Clean Startup**: Removed detailed context loading and budget status messages during initialization
- **ğŸ“ Improved Logging**: INFO/WARN/DEBUG messages now only write to log files, keeping console clean for users
- **ğŸ› Bug Fixes**: Better error handling and user feedback for CLI operations

## ğŸ—ï¸ RPG Repository Planning

**Repository Planning Graph (RPG)** is a cutting-edge approach to software architecture that structures code generation around modular planning. Inspired by the paper ["RPG: A Repository Planning Graph"](https://arxiv.org/abs/2509.16198), this feature ensures your generated codebases are well-organized, maintainable, and scalable.

### ğŸ“– RPG Technical Details

RPG planning works by analyzing your request and creating a structured JSON plan with:

- **Features**: High-level functionalities to implement
- **Files**: Feature-to-file mapping for modular code generation
- **Flows**: Data flow relationships between features
- **Dependencies**: File dependency relationships

### Quick RPG Overview

1. **ğŸ“‹ Planning Phase**: Grok analyzes your request and creates a structured JSON plan
2. **ğŸ—‚ï¸ Graph Construction**: Builds a dependency graph with features and relationships
3. **âš™ï¸ Guided Generation**: Uses the plan to generate modular, well-structured code
4. **ğŸ’¾ Direct Output**: Writes files directly to your filesystem

### When RPG Activates

RPG planning automatically triggers for prompts containing:

- `"generate repo"`, `"build a"`, `"create a"`
- `"implement a"`, `"develop a"`

**Example**: `"Build a simple ML library in JavaScript"` â†’ RPG generates `src/data.js`, `src/model.js`, etc.

### ğŸ“ [RPG Examples](./examples/)

Browse [example RPG plans](./examples/rpg-plans/) for different project types:

- [Machine Learning Library](./examples/rpg-plans/ml-library.json)
- [REST API](./examples/rpg-plans/rest-api.json)
- [CLI Tool](./examples/rpg-plans/cli-tool.json)

---

## âš¡ Key Features

Grok Code combines AI assistance with structured planning for unparalleled coding productivity:

### ğŸ¤– AI-Powered Coding with RPG Planning

- **Intelligent Code Generation**: Natural language prompts powered by Grok AI
- **RPG Planning Integration**: Structured repository planning for complex projects
- **Step-by-Step Reasoning**: Grok thinks ahead, plans, and iterates on solutions
- **Multi-Paradigm Support**: Scripts, libraries, web apps, APIs, and more

### ğŸ§  Enhanced Multi-File Intelligence _(Phase 1)_

- **ğŸ—‚ï¸ Semantic Code Parser**:
  - AST-based analysis for JavaScript, TypeScript, and Python
  - Extracts functions, classes, imports, exports, and dependencies
  - Language-agnostic symbol extraction across multiple files

- **ğŸ”— Dependency Graph Engine**:
  - Maps import/export relationships across entire codebases
  - Detects circular dependencies with detailed cycle analysis
  - ASCII visualization of code architecture and relationships
  - Interactive graph exploration and statistics

- **ğŸ¯ Context Inference System**:
  - Intelligent file relevance scoring based on semantic matching
  - Context window optimization for AI model token limits
  - Smart file suggestions based on coding task analysis
  - Task type detection (bugfix, feature, refactor, test, etc.)

- **ğŸ” Intelligent File Linking**:
  - Semantic search across codebases with meaning-based queries
  - Auto-context building from user queries and file relevance
  - Token-efficient conversation management with pruning strategies
  - Session-aware context that learns from interaction patterns

- **ğŸ’° Context Budgeting System** _(Latest Addition)_:
  - Reserves 15% for essential project files (package.json, README, etc.)
  - Allocates 70% for conversation and work context
  - Maintains 15% buffer for system overhead
  - Prevents capacity exhaustion while ensuring project awareness

### ğŸ”§ Advanced Error Recovery System _(Phase 2)_

- **ğŸ” Intelligent Error Detection**:
  - Parses output from ESLint, TypeScript compiler, Prettier, and more
  - Classifies errors by type, severity, and fix complexity
  - Context-aware error analysis with codebase understanding
  - Impact assessment and prioritization

- **ğŸ”§ Automated Fix Generation**:
  - 20+ fix templates for common errors (missing semicolons, unused variables, imports)
  - Confidence-based auto-application (80%+ confidence = auto-fix)
  - Template â†’ AI â†’ Hybrid fallback strategy for maximum coverage
  - Intelligent method selection based on error characteristics

- **ğŸ¤– AI-Powered Fixes**:
  - Grok integration for complex error resolution
  - Full codebase context provided to AI for accurate fixes
  - Handles type mismatches, architectural issues, and complex logic errors
  - Structured fix output with explanations and warnings

- **ğŸ›¡ï¸ Safe Fix Application**:
  - Automatic file backups before any changes
  - Pre-flight checks (permissions, syntax validation, space)
  - Risk assessment with user confirmation for high-risk fixes
  - Instant rollback capability on any failure
  - Post-fix validation to ensure correctness

- **ğŸ“Š Intelligent Learning Systems**:
  - **Error Pattern Analysis**: Cross-session tracking of error frequency, hotspots, and temporal patterns
  - **Personalized Recommendations**: User-specific fix preferences based on success history and project patterns
  - **Proactive Prevention**: Configuration suggestions, coding practice improvements, and architectural guidance
  - **Continuous Adaptation**: Learns from every interaction to provide better assistance over time

### ğŸ—‚ï¸ Multi-File Management

- **Create, edit, or delete multiple files simultaneously using XML tags**
- **Automatic directory creation for complex project structures**

### ğŸ¨ Syntax Highlighting

- **Multi-language support**: JavaScript, TypeScript, Python, JSON, Shell, SQL
- **Automatic language detection** from code content
- **Multiple color themes**: default, dark, minimal with ANSI terminal colors
- **Line numbers** and enhanced readability
- **Interactive controls**: `/highlight` command for runtime theme switching

### ğŸ“Š Color-Coded Diff Display

- **Unified diff parsing** with full color coding (green/red/gray)
- **Syntax highlighting within diffs** for enhanced readability
- **Git integration** with `/diff git` command for seamless workflow
- **Multi-file diff support** with language-aware highlighting
- **Diff summary statistics** and side-by-side comparisons
- **Interactive diff commands**: `/diff status/test/git/show`

### â³ Progress Indicators & Status Displays

- **Advanced spinner system** with multiple operation types and themes
- **Real-time progress feedback** for all long-running operations
- **Multi-step progress tracking** with sequential execution visualization
- **Status indicators** with success/error/warning/info/pending states
- **Performance timing** with formatted duration displays
- **Interactive progress commands**: `/progress status/test/spinner/multistep`

### ğŸ—‚ï¸ Interactive File Browser

- **Terminal navigation** with arrow keys and intuitive file selection
- **File type icons** with emoji indicators (ğŸ“ directories, ğŸŸ¨ JS, ğŸ”· TS, ğŸ Python, etc.)
- **Syntax-highlighted previews** with metadata (size, type, modification date)
- **Context integration** to add selected files to AI conversation
- **Search and filtering** across directory trees
- **Interactive browser commands**: `/browse start/find/preview/stats`

### ğŸ“„ Enhanced Code Preview

- **Line numbers and gutter** with IDE-style formatting and navigation
- **Syntax highlighting** integrated with multi-language support
- **Line highlighting and navigation** with context-aware display
- **Search and highlight** functionality within code files
- **Code annotations** with inline comments and explanations
- **File metadata display** with size, type, and modification info
- **Interactive preview commands**: `/preview file/line/search/code/config`

### ğŸ” Interactive Code Search

- **Multi-file codebase search** with configurable search modes
- **Regex pattern matching** with fuzzy and whole word search options
- **File type filtering** (JavaScript, TypeScript, Python, web files, configs)
- **Real-time result highlighting** with context previews and line numbers
- **Search history tracking** and usage statistics
- **Interactive search interface** with guided menu-driven experience
- **Advanced search commands**: `/search query/regex/word/fuzzy/interactive/history/stats`

### ğŸ”„ Autonomous Workflows

- **Execute shell commands via `<run command="...">` tags (npm install, tests, linting)**
- **Iterative error handling with AI-suggested fixes**
- **End-to-end project generation with deployment commands**
- **Error recovery workflows** with automatic fix suggestions

### ğŸŒ Git Integration

- **Built-in commands**: `/git <command>`, `/init-git`, `/commit <message>`, `/push`
- **Automated git workflows and PR creation (requires `gh` CLI)**
- **Conflict resolution and commit message generation**

### âš™ï¸ Custom Commands & Configuration

- **Define reusable prompts in `.grok/commands/<cmd_name>.txt`**
- **Team-shared commands for project consistency**
- **GROK.md**: Project-specific guidelines and commands\*\*
- **Context budgeting configuration** for custom capacity allocation

### ğŸ§  Memory & History System

- **Conversation persistence across CLI sessions**
- **Action history with undo/redo functionality (`/undo`)**
- **Context window management** with intelligent budgeting
- **Automatic conversation compression and summarization**

### ğŸ–¥ï¸ Environment Awareness

- **Cross-platform support (Windows, macOS, Linux)**
- **OS-adapted commands and paths**
- **Stateful conversation with full context retention**
- **Model selection with platform-optimized defaults**

### ğŸ¨ Terminal-First UX

- **Thinking animations during API calls**
- **Interactive confirmation for high-risk actions**
- **Comprehensive help system with `/help`**
- **Context capacity dashboard with `/budget`**
- **Session management with `/clear`**

### ğŸ”§ Configuration & Extensibility

- **`GROK.md`**: Project-specific guidelines and commands\*\*
- **Secure API key management with local storage**
- **Model Selection**: Choose from multiple Grok models via `/model` command:
  - `grok-code-fast-1`: **Default** - Optimized for coding, fast & cost-effective
  - `grok-4-fast-reasoning`: Best for complex reasoning (RPG planning), 2M context
  - `grok-4-fast-non-reasoning`: Fast for simple tasks, 2M context, low cost
  - `grok-3-beta`: Legacy - Most capable, balanced performance
  - `grok-3-mini-beta`: Legacy - Faster, lower cost
  - `grok-beta`: Legacy - Original model
- **Environment variables**: Set `GROK_MODEL` to override default

### ğŸ›¡ï¸ Security & Best Practices

- **User confirmation required for high-risk fixes**
- **Automatic backups and rollback for all changes**
- **Token-efficient context management with budgeting**
- **Pre-flight validation for all fix applications**
- **No automatic execution without approval**

## Installation

1. **Prerequisites**:
   - Node.js 16+.
   - xAI API key (get from [x.ai/api](https://x.ai/api)).

2. **Clone the Repo**:

   ```bash
   git clone https://github.com/NYTEMODEONLY/grok-code.git
   cd grok-code
   ```

3. **Install Dependencies**:

   ```bash
   npm install
   ```

4. **Run the CLI**:

   ```bash
   npm start
   ```

   or

   ```bash
   ./bin/grok.js
   ```

   - On first launch, enter your xAI API key (saved securely in `~/.grok/api_key`).

5. **Global Installation (Optional)**:
   ```bash
   npm install -g .
   ```
   Or install from npm (once published):
   ```bash
   npm install -g grok-code-cli
   ```
   Then use `grok` from anywhere.

## ğŸš€ Quick Start

Get started with Grok Code in seconds:

```bash
# Clone and install
git clone https://github.com/NYTEMODEONLY/grok-code.git
cd grok-code
npm install

# Launch
npm start
```

Or install globally for system-wide access:

```bash
npm install -g grok-code-cli
grok
```

### ğŸ’¡ Usage Examples

#### ğŸ—ï¸ RPG Planning (Recommended for Complex Projects)

```bash
# Automatic RPG activation
"Build a simple ML library in JavaScript"
"Create a REST API for task management"
"Implement a React dashboard with charts"
"Develop a Node.js CLI tool for file processing"
```

#### ğŸ¤– Regular AI Chat

```bash
# General coding assistance
"Write a function to validate email addresses"
"Debug this JavaScript error: [paste error]"
"Optimize this SQL query for performance"
```

#### ğŸ”§ Workflow Commands

```bash
# Model selection
"/model"                       # Change AI model (interactive menu)

# Context management
"/budget"                      # Show context capacity and usage breakdown
"/add src/app.js"              # Add file to conversation context (capacity-aware)
/scan                          # Scan all files (with capacity warnings)
/remove src/app.js             # Remove file from context and free capacity

# Git operations
"/init-git"                    # Initialize repository
"/commit Add new feature"      # Stage and commit
"/push"                        # Push to remote

# File management
"/ls"                          # List directory

# Memory & history
"/undo"                        # Undo the last file operation
"/clear"                       # Clear conversation history

# Custom commands
"/test"                        # Run tests (if defined)

# Error recovery (Phase 2)
# Just paste error output - Grok Code will analyze and suggest fixes
# Example: Paste ESLint/TypeScript errors for automatic analysis
```

Exit anytime with `exit` or `/exit`. Conversations are automatically saved and restored between sessions.

### ğŸ“‹ Example Sessions

#### ğŸ—ï¸ RPG Planning Example

```bash
Welcome to Grok Code! Type your message or use /help for commands.

You: Build a simple ML library in JavaScript

Grok: Using RPG planning for code generation...
RPG Plan Generated: {
  "features": ["data_loading", "model_training", "prediction"],
  "files": {"data_loading": "src/data.js", "model_training": "src/model.js"},
  "flows": [["data_loading", "model_training"]],
  "deps": [["data.js", "model.js"]]
}

Generated: src/data.js
Generated: src/model.js
Generated: package.json

Repository generation completed!
```

#### ğŸ¤– Interactive Development Example

**Create and test code instantly:**

```bash
# User creates a function
You: Create a function to reverse a string in JavaScript

Grok: Here's a simple function to reverse a string:
```

```javascript
function reverseString(str) {
  return str.split('').reverse().join('');
}
```

```bash
# User immediately tests the function
You: /run node -e "console.log(reverseString('hello'))"

[Command executed: node -e "console.log(reverseString('hello'))"]
Output: olleh
```

#### ğŸ›¡ï¸ Error Recovery System Example

```bash
# User encounters a linting error
You: [pastes ESLint output]
src/auth.js:15:25: Missing semicolon (semi)
src/auth.js:20:7: 'unusedVar' is defined but never used (no-unused-vars)

Grok: ğŸ” Analyzing 2 errors across your codebase...

Error Analysis:
â€¢ SYNTAX: Missing semicolon (High confidence auto-fix available)
â€¢ UNUSED: Unused variable (High confidence auto-fix available)

ğŸ¤– Applying fixes...
âœ… Fixed: Missing semicolon in src/auth.js:15
âœ… Fixed: Removed unused variable 'unusedVar' in src/auth.js:20

All errors resolved! Your code is now clean.
```

#### ğŸ’° Context Budgeting Example

```bash
# Check context capacity
You: /budget

ğŸ’° Context Budget Status:
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
Total Usage: 15% (1200/8000 tokens)
Available: 6800 tokens

Budget Categories:
  essentials â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–‘â–‘â–‘â–‘ 15% (1200/8000)
  conversation â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘ 0% (0/5600)
  buffer â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–‘â–‘â–‘â–‘ 15% (1200/8000)

ğŸ’¡ Tips:
   â€¢ You have 5600 tokens available for conversation
   â€¢ Essentials usage is optimal (README.md, package.json loaded)

# Add a file to conversation context
You: /add src/utils/helpers.js
âœ… Added src/utils/helpers.js to context (450 tokens).
ğŸ’° Conversation capacity: 5150 tokens remaining

# View updated budget
You: /budget
[Shows updated usage with conversation category now active]
```

## ğŸ’¡ Best Practices & Tips

### ğŸ—ï¸ RPG Planning Tips

- **Use Descriptive Prompts**: "Build a REST API for user authentication" works better than "Make an API"
- **Complex Projects**: Always use RPG for multi-feature projects to ensure proper architecture
- **Review Plans**: RPG plans are logged to consoleâ€”review them before generation
- **Fallback Available**: If RPG fails, Grok Code automatically falls back to regular chat

### ğŸ¤– General AI Usage

- **Context Matters**: Add relevant files with `/add <file>` before complex tasks
- **Iterative Development**: Use Grok's error analysis for debugging workflows
- **Token Efficiency**: Add files selectively rather than scanning everything

### ğŸ“ Project Configuration

- **GROK.md**: Define project standards:

  ```markdown
  # Project Standards

  - Style: ESLint with Airbnb preset
  - Build: npm run build
  - Test: npm test
  - Architecture: Feature-based folder structure
  ```

- **Custom Commands**: Create reusable workflows:
  ```bash
  # .grok/commands/deploy.txt
  Deploy the current Next.js app to Vercel and output the URL.
  ```

### ğŸ’° Context Budgeting Best Practices

- **Monitor Capacity**: Use `/budget` regularly to understand your context usage
- **Essential Files**: Only README.md and package.json are auto-loaded - add others manually
- **Conversation Priority**: Reserve most capacity (70%) for actual work discussions
- **Capacity Warnings**: Pay attention to capacity warnings when adding files
- **Selective Addition**: Use `/add <file>` instead of `/scan` for better capacity control

### ğŸ”§ Error Recovery Tips

- **Paste Raw Errors**: Just paste ESLint/TypeScript errors directly - Grok Code analyzes automatically
- **Trust Auto-Fixes**: High-confidence fixes (>80%) are applied automatically and safely
- **Review AI Fixes**: Lower-confidence fixes show suggestions instead of auto-applying
- **Rollback Ready**: All fixes can be rolled back instantly if something goes wrong
- **Context Matters**: Add relevant files before fixing complex errors for better results

### âš¡ Performance Optimization

- **Model Selection**: Use `/model` command to choose the right model for your task:
  - **Coding tasks**: `grok-code-fast-1` (default - optimized for code)
  - **Complex reasoning/RPG**: `grok-4-fast-reasoning` (2M context, excellent reasoning)
  - **Simple/fast tasks**: `grok-4-fast-non-reasoning` (2M context, low cost)
  - **High quality**: `grok-3-beta` (legacy - most capable)
  - **Speed/cost**: `grok-3-mini-beta` (legacy - fastest)
- **Context Management**: Use `/budget` to monitor capacity instead of clearing sessions
- **Selective Scanning**: Use `/add` with capacity awareness for large codebases
- **Fix Learning**: The system learns from your fix patterns for better suggestions

## ğŸ¤ Contributing

We love contributions! Whether it's bug fixes, new features, or documentation improvements, every contribution helps make Grok Code better.

### ğŸš€ How to Contribute

1. **Fork** the repository on GitHub
2. **Clone** your fork: `git clone https://github.com/your-username/grok-code.git`
3. **Create** a feature branch: `git checkout -b feature/amazing-feature`
4. **Make** your changes and test thoroughly
5. **Commit** with clear messages: `git commit -m "Add amazing feature"`
6. **Push** to your branch: `git push origin feature/amazing-feature`
7. **Open** a Pull Request with a detailed description

### ğŸ› Found a Bug?

- Check [existing issues](https://github.com/NYTEMODEONLY/grok-code/issues) first
- Open a new issue with detailed steps to reproduce
- Include your OS, Node.js version, and error messages

### ğŸ’¡ Feature Requests

- Use GitHub Discussions for feature ideas
- Check if the feature aligns with RPG planning principles
- Provide use cases and examples

## ğŸ“„ License

This project is licensed under the MIT License - see the [LICENSE](LICENSE) file for details.

## ğŸ™ Acknowledgments

- **ğŸ¤– Powered by** [xAI's Grok](https://x.ai) models - The foundation of intelligent assistance
- **ğŸ“š Inspired by** ["RPG: A Repository Planning Graph"](https://arxiv.org/abs/2509.16198) - Structured planning for better code generation
- **ğŸ‘¨â€ğŸ’» Built by** nytemode - Personal project exploring AI-assisted development
- **ğŸŒŸ xAI Community** - For providing the amazing models that make this possible

_This is a personal project and not officially affiliated with xAI._

## ğŸ“ Support & Community

- **ğŸ› Issues**: [GitHub Issues](https://github.com/NYTEMODEONLY/grok-code/issues)
- **ğŸ’¬ Discussions**: [GitHub Discussions](https://github.com/NYTEMODEONLY/grok-code/discussions)
- **ğŸ¦ Twitter**: Follow [@xai](https://twitter.com/xai) for updates
- **ğŸ“§ Contact**: Open an issue for direct support

---

<div align="center">

**Ready to revolutionize your coding workflow?** ğŸš€

[Get Started](#quick-start) â€¢ [RPG Planning](#rpg-repository-planning) â€¢ [Contribute](#contributing)

_Made with â¤ï¸ by nytemode_

</div>
